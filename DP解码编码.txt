#include<iostream>
#include<string.h>
using namespace std;
long long dp[55][2];
int main()
{
	memset(dp,0,sizeof(dp));
	dp[1][1]=1;
	dp[1][0]=1;
	for(int i=2;i<44;i++)
	{
		dp[i][0]=dp[i-1][0]+dp[i-1][1];
		dp[i][1]=dp[i-1][0];
	}
	int n;
	long long k;
	while(cin>>n>>k)
	{
		if(k>dp[n][0]+dp[n][1])
		{
			cout<<"-1"<<endl;
			continue;
		}
		while(n)
		{
			if(dp[n][0]>=k)
			{
				cout<<0;
			}
			else
			{
				cout<<1;
				k-=dp[n][0];
			}
			n--;
		}
		cout<<endl;
	}
	return 0;
}


一个串，把右端的叫低位，叫第1位，左端的叫高位，叫第43位，（最多这么多位）
dp[n][0]，表示第n位放0，到第1位，一共能产生多少个串
dp[n][1]，表示第n位放1，到第1位，一共能产生多少个串

如果按照字典序来排，肯定第n位放0的话，字典序比放1的要小（无需考虑后面的）
现在要找第m个排序，看看第n位放0的话，能产生多少个排列，如果放0，产生的排序数都不够m大，那么这一位肯定是放1的，放了1，就应该从m-dp[n][0]重新考虑了，因为相当于你排除了放0的所有情况

求dp数组是一个从低位向高位编码的过程
求第m个排列，是一个从高位向低位解码的过程，解码就是从高位到低位，一位一位地确定到底是放1还是放0

DP(解码)
题意：给出一个串的长度n，串只有0,1组成，但是不能有两个相邻的1。按字典序给串排列，最先肯定是0000，接着是0001，依此类推。给一个数字m，输出在长度为n的情况下，第m个排列的串是什么，如果m大于总排列数，输出-1
 
这其实是一个解码的过程，必须用高位到低位解码（从左到右），因为这里要求字典序，字典序的比较水从左到右的
由于数据规模固定在串长度44以内，所以我们先dp出所有长度下可能的排列数，编码时也要用
每次编码按位编码，判断当前位为0还是为1，就是看填0或1可能产生多少排列数然后和m比较，这个看代码大概都能懂的
