//kmp算法一般在百万级
//求子串的最多重复次数，不重叠 
 #include<iostream>
 #include<string>
 #include<string.h>
 using namespace std;
 int len;
 char s[1000005];
 int next1[1000005];
 
  void getnext()
  {
 	int i=0,j=-1;
 	next1[0]=-1;
 	while(i<len)
 	{ 
 	 if(j==-1||s[i]==s[j])
	 {
 		i++;
 		j++;
 		next1[i]=j;
 	 }
 	 else
 	   j=next1[j];
 	 } 
 }
 
 int main()
 {
 	while(cin>>s)
 	{
 		int ans=1;
	 	if(s[0]=='.')
	 	break;
	 	len=strlen(s);
	 	getnext();//不要忘记调用这个函数 
	 	
	 	if(len%(len-next1[len])==0)
        ans=len/(len-next1[len]);
   
        cout<<ans<<endl;
	 }
	 return 0;
 }  
 


对于代码中i-next[i]代表了字符串最小前缀且满足能不但的复制得到
原字符串；len%(i-next[i])==0时代表字符串刚刚是子串的整数倍；
 
若len%(i-next[i])==0匹配时每一次移动的距离i-next[i]是相等的，若不等则只有最后一次不等；

 /* 计算首尾重复子串的长度 */
        j = i - next[i];
        printf("%d %d %d\n", i, next[i], j);
        /* 若串满足重复性质，则i%j==0；否则重复子串为本身 */
        if (i % j == 0) k = i / j;
        else k = 1;
        printf("%d\n", k);
    }


1]...p[j-1]'}，应该不包含子串为本身的情况...
这样再做PKU 2406 和 PKU 1961 的时候就很简单了，用 length - next[length] 求出"不为自身的最大首尾重复子串长度"，此时需要多求一位next[length]值，若最大重复子串的长度是length的非1整数倍，则证明字符串具有周期重复性质。
PKU 2752 是求 前缀 == 后缀 的长度，也就是首尾重复子串长度，利用next数组记录的"不为自身的最大首尾重复子串长度"可以马上得到结果。
这道题是考察对next数组性质的应用。题意相当于是求一个长字符串中循环节的个数。
　　由于我们知道next数组中存的是一个位置(假设next[j]的值为k，对应的字符串为M,如果k>0,那么M[0....k-1]和M[j-k.....j-1]是相同的，并且0...k-1这个序列一定是最长的)，比如a b c a b c d(next值：-1 0 0 0 1 2 3 )，由next[6]=3可知，M[0..2]=M[3..6]，这就找到了循环节，于是我们思考从next数组作为切入点，来找到一种方法来求得循环节的个数。
　　看看next数组的一个性质：next始终是从-1开始增加(在变为0之前)。这会导致一个有趣的现象：指针回溯的位置，最远都是在一个完整的循环节之后。其实由定义也能发现，如果最远回溯到了字符串开头，就会导致j=k,与next数组的定义中的0<k<j矛盾。这样，就留出来了一个循环节的长度，如果总长度是这个循环节长度的整数倍，那么循环节的个数就是这个倍数。反之，说明这个字符串并不是在不停地循环，而是在某些位置加入了一个或几个不"和谐"的字符，导致指针无法回溯到第一个循环节之后，这样，输出1就可以了。
