描述： 有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。

分析：要求n个石子归并，我们根据dp的思想划分成子问题，先求出每两个合并的最小代价，然后每三个的最小代价，依次知道n个。
定义状态dp [ i ] [ j ]为从第i个石子到第j个石子的合并最小代价。
那么dp [ i ] [ j ] = min(dp [ i ] [ k ] + dp [ k+1 ] [ j ]) 
那么我们就可以从小到大依次枚举让石子合并，直到所有的石子都合并。
这个问题可以用到平行四边形优化，用一个s【i】【j】=k 表示区间 i---j 从k点分开才是最优的，这样的话我们就可以优化掉一层复杂度，变为O（n^2）.
由于决策s具有单调性,因此状态转移方程可修改为:
 m[i][j]=min {m[i][k-1]+m[k][j]+w[i][j]} , (s[i][j-1]<=k<=s[i+1][j])//这就是四边形优化
1.#include?<cstdio>??
2.#include?<cstring>??
3.#include?<algorithm>??
4.#define?N?210??
5.int?dp[N][N],sum[N];??
6.int?main()??
7.{??
8.????int?n;??
9.????while(~scanf("%d",&n))??
10.????{??
11.????????int?a[N];sum[0]=0;??
12.????????for(int?i=1;i<=n;i++){??
13.????????????scanf("%d",&a[i]);??
14.????????????sum[i]=sum[i-1]+a[i];??
15.????????}??
16.????????memset(dp,0,sizeof(dp));??
17.????????int?i,j,l,k;??
18.????????for(l?=?2;?l?<=?n;?++l)??
19.????????{??
20.????????????for(i?=?1;?i?<=?n?-?l?+?1;?++i)??
21.????????????{??
22.????????????????j?=?i?+?l?-?1;??
23.????????????????dp[i][j]?=?2100000000;??
24.????????????????for(k?=?i;?k?<?j;?++k)??
25.????????????????{??
26.????????????????????dp[i][j]?=?std::min(dp[i][j],dp[i][k]?+?dp[k?+?1][j]?+?sum[j]?-?sum[i-1]);??
27.????????????????}??
28.????????????}??
29.????????}??
30.????????printf("%d\n",?dp[1][n]);??
31.????}??
32.????return?0;??
33.}??

平行四边形优化代码：
1.#include?<cstdio>??
2.#include?<cstring>??
3.#include?<algorithm>??
4.#define?N?210??
5.int?dp[N][N],sum[N],s[N][N];??
6.int?main()??
7.{??
8.????int?n;??
9.????while(~scanf("%d",&n))??
10.????{??
11.????????int?a[N];sum[0]=0;??
12.????????memset(s,0,sizeof(s));??
13.????????for(int?i=1;i<=n;i++){??
14.????????????scanf("%d",&a[i]);??
15.????????????s[i][i]=i;??//四边形优化的初始化
16.????????????sum[i]=sum[i-1]+a[i];??
17.????????}??
18.????????memset(dp,0,sizeof(dp));??//notice
19.????????int?i,j,l,k;??
20.????????for(l?=?2;?l?<=?n;?++l)??
21.????????{??
22.????????????for(i?=?1;?i?<=?n?-?l?+?1;?++i)??
23.????????????{??
24.????????????????j?=?i?+?l?-?1;??
25.????????????????dp[i][j]?=?2100000000;??//这也是必须的
26.????????????????for(k?=?s[i][j-1];?k?<=?s[i+1][j];?++k)??
27.????????????????{??
28.????????????????????if(dp[i][j]>dp[i][k]?+?dp[k?+?1][j]?+?sum[j]?-?sum[i-1])??
29.????????????????????{??
30.????????????????????????dp[i][j]=dp[i][k]?+?dp[k?+?1][j]?+?sum[j]?-?sum[i-1];??
31.????????????????????????s[i][j]=k;??
32.????????????????????}??
33.????????????????}??
34.????????????}??
35.????????}??
36.????????printf("%d\n",?dp[1][n]);??
37.????}??
38.????return?0;??
39.}??
如果石子组成的是一个圈的话，那么就先将圈化成链，最后进行动态规划后枚举
k即分开的结点罢了，复杂度如下
