Contents
一、定义
二、	详解
三、	例题



一、定义（百度百科）：
如果一个系统由n个变量和m个约束条件组成，其中每个约束条件形如xj-xi<=bk(i,j∈[1,n],k∈[1,m]),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。
求解差分约束系统，可以转化成图论的单源最短路径（或最长路径）问题。
观察xj-xi<=bk，会发现它类似最短路中的三角不等式d[v]<=d[u]+w[u,v]，即d[v]-d[u]<=w[u,v]。因此，以每个变量xi为结点，对于约束条件xj-xi<=bk，连接一条边(i,j)，边权为bk。我们再增加一个源点s,s与所有定点相连，边权均为0。对这个图，以s为源点运行Bellman-ford算法（或SPFA算法），最终{d[ i]}即为一组可行解。
例如，考虑这样一个问题，寻找一个5维向量x=(xi)以满足：
这一问题等价于找出未知量xi，i=1,2,…,5，满足下列8个差分约束条件：

x1-x2≤0
x1-x5≤-1
x2-x5≤1
x3-x1≤5
x4-x1≤4
x4-x3≤-1
x5-x3≤-3
x5-x4≤-3
该问题的一个解为x=(-5,-3,0,-1,-4)，另一个解y=(0,2,5,4,1)，这2个解是有联系的：y中的每个元素比x中相应的元素大5。
引理：设x=(x1,x2,…,xn)是差分约束系统Ax≤b的一个解，d为任意常数。则x+d=(x1+d,x2+d,…,xn+d)也是该系统Ax≤b的一个解。
bellman-ford算法伪代码：
for each v V do d[v] <-- 无限大; d[s] <-- 0
Relaxation
for i =1,...,|V|-1 do
for each edge (u,v) 属于 E do
d[v] <-- min{d[v], d[u]+w(u,v)}
Negative cycle checking
for each v 属于V do if d[v]> d[u] + w(u,v) then no solution
在实际的应用中，一般使用SPFA(Shortest Path Fast Algorithm)算法来实现。
差分约束系统中源点到每个点的距离确定
关于Dist[]的初始化化
1.如果将源点到各点的距离初始化为0，最终求出的最短路满足 它们之间相互最接近了
2.如果将源点到各点的距离初始化为INF(无穷大)，其中之1为0，最终求出的最短路满足 它们与该点之间相互差值最大。
3.差分约束系统的确立要根据自己确定的约束条件，从约束点走向被约束点
连边一般有两种方法，第一种是连边后求最长路的方法，第二种是连边后求最短路的方法。
例：d[x]-d[y]>=Z
如果想连边后求最长路 那么将不等式变形为这种形式 d[x]>=d[y]+z y---x连一条权值为z的边
求最短路则变形成d[y]<=d[x]-z x---y连一条权值为-z的边。
如果是别的不等式，也可以根据情况变形。但是要保证的是 两个变量（x,y)的系数一定要是正的。而常量则不一定。
定理：将如上差分约束系统

转换成图后，以

为源点得到的最短路径序列为

（如果有解），则

满足

且若

为

任意解，则有

。
证明：首先由

，则显然有

满足

，这是因为每条边对应一个不等式且由图的构造法可知。其次考察

到

的最短路径

，我们有

与

直接相连且由路径最短知

，其中

为不等式

的常量即为边

的权，所以有

。对k做归纳，由

，又

，所以

即

所以后者成立。证毕
例：设有n个盒子标号为1...n，每个盒子最多放1个球。放法满足

（0<i≤m）约束，其中

表示区间

最多可放

个球，求这n个盒子最多可放多少个球。[1]
令前k个盒子放的数目为

，则有

，

（1 ≤?i?≤?n?），

（1 ≤?i?≤?m）。以此约束条件用如上算法给出最短路径序列

，由定理知

是合法的放法，且

为最大值。
二、详解
引自某网友：
（本文假设读者已经有以下知识：最短路径的基本性质、Bellman-Ford算法。）?
??? 比如有这样一组不等式：?
???
X1 - X2 <= 0?
X1 - X5 <= -1?
X2 - X5 <= 1?
X3 - X1 <= 5?
X4 - X1 <= 4?
X4 - X3 <= -1?
X5 - X3 <= -3?
X5 - X4 <= -3?
不等式组(1)?

??? 全都是两个未知数的差小于等于某个常数（大于等于也可以，因为左右乘以-1就可以化成小于等于）。这样的不等式组就称作差分约束系统。?
??? 这个不等式组要么无解，要么就有无数组解。因为如果有一组解{X1, X2, ..., Xn}的话，那么对于任何一个常数k，{X1 + k, X2 + k, ..., Xn + k}肯定也是一组解，因为任何两个数同时加一个数之后，它们的差是不变的，那么这个差分约束系统中的所有不等式都不会被破坏。?
????
??? 差分约束系统的解法利用到了单源最短路径问题中的三角形不等式。即对于任何一条边u -> v，都有：?

d(v) <= d(u) + w(u, v)?

??? 其中d(u)和d(v)是从源点分别到点u和点v的最短路径的权值，w(u, v)是边u -> v的权值。?
??? 显然以上不等式就是d(v) - d(u) <= w(u, v)。这个形式正好和差分约束系统中的不等式形式相同。于是我们就可以把一个差分约束系统转化成一张图，每个未知数Xi对应图中的一个顶点Vi，把所有不等式都化成图中的一条边。对于不等式Xi - Xj <= c，把它化成三角形不等式：Xi <= Xj + c，就可以化成边Vj -> Vi，权值为c。最后，我们在这张图上求一次单源最短路径，这些三角形不等式就会全部都满足了，因为它是最短路径问题的基本性质嘛。?
??? 话说回来，所谓单源最短路径，当然要有一个源点，然后再求这个源点到其他所有点的最短路径。那么源点在哪呢？我们不妨自已造一个。以上面的不等式组为例，我们就再新加一个未知数X0。然后对原来的每个未知数都对X0随便加一个不等式（这个不等式当然也要和其它不等式形式相同，即两个未知数的差小于等于某个常数）。我们索性就全都写成Xn - X0 <= 0，于是这个差分约束系统中就多出了下列不等式：?
????
X1 - X0 <= 0?
X2 - X0 <= 0?
X3 - X0 <= 0?
X4 - X0 <= 0?
X5 - X0 <= 0?
不等式组(2)?

??? 对于这5个不等式，也在图中建出相应的边。最后形成的图如下：?
?

图1?

??? 图中的每一条边都代表差分约束系统中的一个不等式。现在以V0为源点，求单源最短路径。最终得到的V0到Vn的最短路径长度就是Xn的一个解啦。从图1中可以看到，这组解是{-5, -3, 0, -1, -4}。当然把每个数都加上10也是一组解：{5, 7, 10, 9, 6}。但是这组解只满足不等式组(1)，也就是原先的差分约束系统；而不满足不等式组(2)，也就是我们后来加上去的那些不等式。当然这是无关紧要的，因为X0本来就是个局外人，是我们后来加上去的，满不满足与X0有关的不等式我们并不在乎。?
??? 也有可能出现无解的情况，也就是从源点到某一个顶点不存在最短路径。也说是图中存在负权的圈。这一点我就不展开了，请自已参看最短路径问题的一些基本定理。?

??? 其实，对于图1来说，它代表的一组解其实是{0, -5, -3, 0, -1, -4}，也就是说X0的值也在这组解当中。但是X0的值是无可争议的，既然是以它作为源点求的最短路径，那么源点到它的最短路径长度当然是0了。因此，实际上我们解的这个差分约束系统无形中又存在一个条件：?

X0 = 0?

??? 也就是说在不等式组(1)、(2)组成的差分约束系统的前提下，再把其中的一个未知数的值定死。这样的情况在实际问题中是很常见的。比如一个问题表面上给出了一些不等式，但还隐藏着一些不等式，比如所有未知数都大于等于0或者都不能超过某个上限之类的。比如上面的不等式组(2)就规定了所有未知数都小于等于0。?
????
??? 对于这种有一个未知数定死的差分约束系统，还有一个有趣的性质，那就是通过最短路径算法求出来的一组解当中，所有未知数都达到最大值。下面我来粗略地证明一下，这个证明过程要结合Bellman-Ford算法的过程来说明。?
??? 假设X0是定死的；X1到Xn在满足所有约束的情况下可以取到的最大值分别为M1、M2、……、Mn（当然我们不知道它们的值是多少）；解出的源点到每个点的最短路径长度为D1、D2、……、Dn。?
??? 基本的Bellman-Ford算法是一开始初始化D1到Dn都是无穷大。然后检查所有的边对应的三角形不等式，一但发现有不满足三角形不等式的情况，则更新对应的D值。最后求出来的D1到Dn就是源点到每个点的最短路径长度。?
??? 如果我们一开始初始化D1、D2、……、Dn的值分别为M1、M2、……、Mn，则由于它们全都满足三角形不等式（我们刚才已经假设M1到Mn是一组合法的解），则Bellman-Ford算法不会再更新任合D值，则最后得出的解就是M1、M2、……、Mn。?
??? 好了，现在知道了，初始值无穷大时，算出来的是D1、D2、……、Dn；初始值比较小的时候算出来的则是M1、M2、……、Mn。大家用的是同样的算法，同样的计算过程，总不可能初始值大的算出来的结果反而小吧。所以D1、D2、……、Dn就是M1、M2、……、Mn。?
????
??? 那么如果在一个未知数定死的情况下，要求其它所有未知数的最小值怎么办？只要反过来求最长路径就可以了。最长路径中的三角不等式与最短路径中相反：?

d(v) >= d(u) + w(u, v)?
也就是 d(v) - d(u) >= w(u, v)?

??? 所以建图的时候要先把所有不等式化成大于等于号的。其它各种过程，包括证明为什么解出的是最小值的证法，都完全类似。?
????
??? 用到差分约束系统的题目有ZJU 2770，祝好运。

三、	例题
POJ--1201[Intervals] 基础的差分约束：
题目大意：
给出N个整数区间[ai,bi]，并且给出一个约束ci，（ 1<= ci <= bi-ai+1），使得数组Z在区间[ai,bj]的个数>= ci个，求出数组Z的最小长度。
分析：
对于给定的条件，假设S[j]为数组Z在[0,j]上的包含的元素个数，则我们可以根据条件得到S[bi+1] - S[ai] >= ci ===> S[ai] - S[bi+1] <= -ci，而且我们在根据隐含的条件1 >= S[j+1]-S[j] >= 0，可以得到一个差分约束系统。但是题目要求我们的是求约束图的最长路径，则我们应该反过来做，令S[N] = 0，从终点开始求。 
若要满足不等式V(a)<=V(b)+W(b,a),则可以从b到a连一条权为W(b,a)的边,求最短路得之。
从b到a的最短路意味着满足所有不等式的a-b之最大值。
即a-b<=w =》b-a>=-w,所有-w就是所求的ans

CODE：
[cpp]?view plaincopy
1./*差分约束*/??
2./*AC代码：375ms*/??
3.#include?<iostream>??
4.#define?MAXN?50005??
5.#define?INF?0x7fffffff??
6.using?namespace?std;??
7.struct?edge??
8.{??
9.????int?to,w,next;???
10.}E[3*MAXN];??
11.int?head[MAXN],ecnt;??
12.int?Stack[MAXN],dis[MAXN],cnt[MAXN];??
13.bool?Instack[MAXN];??
14.int?N,top,l,r;??
15.void?Insert(int?from,int?to,int?w)??
16.{??
17.????E[ecnt].to=to;??
18.????E[ecnt].w=w;??
19.????E[ecnt].next=head[from];??
20.????head[from]=ecnt++;???
21.}??
22.bool?Relax(int?from,int?to,int?w)??
23.{??
24.????if(dis[to]>dis[from]+w)??
25.????{??
26.????????dis[to]=dis[from]+w;??
27.????????return?true;???
28.????}???
29.return?false;??
30.}??
31.void?Init()??
32.{??
33.????int?i,u,v,w;??
34.????memset(head,-1,sizeof(head));ecnt=0;??
35.????l=INF;r=-INF;??
36.????//S[u]-S[v+1]<=-w??
37.????for(i=1;i<=N;i++)??
38.????{??
39.????????scanf("%d%d%d",&u,&v,&w);??
40.????????if(u<l)?l=u;??
41.????????if(v+1>r)?r=v+1;??
42.????????Insert(v+1,u,-w);?????
43.????}??
44.????for(i=l;i<r;i++)??
45.????{??
46.????????Insert(i+1,i,0);//S[i]-S[i+1]<=0???
47.????????Insert(i,i+1,1);//S[i+1]-S[i]<=1???
48.????}??
49.}??
50.void?SPFA(int?s,int?e)???
51.{??
52.????int?i,u,v;??
53.????top=0;??
54.????memset(Instack,false,sizeof(Instack));??
55.????for(i=s;i<=e;i++)??
56.????????dis[i]=INF;??
57.????dis[e]=0;//注意要从e开始??
58.????Stack[++top]=e;??
59.????Instack[e]=true;??
60.????while(top)??
61.????{??
62.????????u=Stack[top--];??
63.????????Instack[u]=false;//出栈??
64.????????for(i=head[u];i!=-1;i=E[i].next)??
65.????????{??
66.????????????v=E[i].to;??
67.????????????if(Relax(u,v,E[i].w)&&!Instack[v])??
68.????????????{??
69.????????????????Instack[v]=true;??
70.????????????????Stack[++top]=v;??
71.????????????}??
72.????????}??
73.????}??
74.}??
75.int?main()??
76.{??
77.????while(scanf("%d",&N)!=EOF)??
78.????{??
79.????????Init();??
80.????????SPFA(l,r);??
81.????????printf("%d\n",-dis[l]);?//必有解，无需判负环??
82.????}?
83.return?0;??
84.}??
